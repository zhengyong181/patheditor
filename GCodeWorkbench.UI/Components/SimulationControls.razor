@namespace GCodeWorkbench.UI.Components

<div class="absolute bottom-3 right-3 z-20">
    <div class="bg-[#1b3224]/95 backdrop-blur border border-border-dark shadow-lg rounded-lg px-2.5 py-2 flex flex-col gap-2 w-64">
        <!-- Row 1: Buttons + Speed -->
        <div class="flex items-center gap-2">
            <!-- Play/Pause Button -->
            <button class="size-7 shrink-0 rounded-full flex items-center justify-center bg-primary text-[#122118] hover:brightness-110 transition shadow-sm"
                    @onclick="OnPlay">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    @if (IsPlaying)
                    {
                        <rect x="6" y="4" width="4" height="16" rx="1"/>
                        <rect x="14" y="4" width="4" height="16" rx="1"/>
                    }
                    else
                    {
                        <polygon points="6 3 20 12 6 21 6 3"/>
                    }
                </svg>
            </button>
            <!-- Stop Button -->
            <button class="size-7 shrink-0 rounded-full flex items-center justify-center bg-white/10 text-white/70 hover:bg-white/20 transition shadow-sm"
                    @onclick="OnStop">
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    <rect x="6" y="6" width="12" height="12" rx="1"/>
                </svg>
            </button>
            
            <div class="w-px h-5 bg-border-dark shrink-0"></div>
            
            <!-- Speed Control -->
            <div class="flex-1 flex items-center gap-1.5 min-w-0">
                <div class="flex-1 relative h-1 flex items-center">
                    <!-- Center Marker -->
                    <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-0.5 h-2 bg-white/30 rounded-sm z-0"></div>
                    <input type="range" 
                           min="0" 
                           max="100" 
                           step="1" 
                           value="@GetLocalSliderValue()"
                           @oninput="HandleSpeedSliderInput"
                           class="w-full h-1 bg-black/40 rounded-lg appearance-none cursor-pointer accent-primary relative z-10" />
                </div>
                <span class="text-[9px] font-mono text-white/70 w-6 text-right shrink-0">@GetCurrentDisplaySpeed().ToString("F1")x</span>
            </div>
        </div>
        
        <!-- Row 2: Progress Bar -->
        <div class="flex items-center gap-1.5">
             <div class="flex-1 h-1 flex items-center">
                <input type="range" 
                       min="0" 
                       max="100" 
                       step="0.1" 
                       value="@Progress"
                       @oninput="HandleProgressChange"
                       class="w-full h-1 bg-black/40 rounded-lg appearance-none cursor-pointer accent-primary" />
             </div>
            <span class="text-[9px] font-mono text-white/70 w-6 text-right shrink-0">@Progress.ToString("F0")%</span>
        </div>
        
        <!-- Row 3: Time Display (Scaled by Speed) -->
        <div class="text-center text-[9px] font-mono text-white/60">
            @FormatDetailedTime(GetScaledTime(CurrentTime)) / @FormatDetailedTime(GetScaledTime(TotalTime))
        </div>
    </div>
</div>

@code {
    [Parameter] public double CurrentTime { get; set; }
    [Parameter] public double TotalTime { get; set; }
    [Parameter] public double Progress { get; set; }
    [Parameter] public bool IsPlaying { get; set; }
    [Parameter] public double PlaybackSpeed { get; set; }
    [Parameter] public EventCallback OnPlay { get; set; }
    [Parameter] public EventCallback OnStop { get; set; }
    [Parameter] public EventCallback<double> OnProgressChanged { get; set; }
    [Parameter] public EventCallback<double> OnSpeedChanged { get; set; }

    private double? _localSpeed; // Stores local speed during drag

    protected override void OnParametersSet()
    {
        // When parameters update from outside, clear local override unless dragging?
        // Actually, we should sync unless we just emitted an event.
        // For simplicity, we assume external updates are authoritative, 
        // but to avoid jitter during drag, we might rely on Blazor's diffing or just update _localSpeed if it's null.
        if (_localSpeed == null)
        {
            _localSpeed = PlaybackSpeed;
        }
        else if (Math.Abs(_localSpeed.Value - PlaybackSpeed) < 0.001)
        {
             // Synced
        }
        else
        {
             // External change overrides local? Or keep local if dragging? 
             // Let's just track PlaybackSpeed if not dragging logic is complex.
             // Simple approach: Always use PlaybackSpeed for calculation unless we are in the middle of an input event?
             // Since we use oninput -> InvokeAsync -> Parent updates PlaybackSpeed -> ParametersSet,
             // the cycle is fast enough. Let's just use data-binding properly.
        }
    }

    private double GetCurrentDisplaySpeed()
    {
        // Use local speed if set (during interaction), else parameter
        return _localSpeed ?? PlaybackSpeed;
    }

    private double GetScaledTime(double time)
    {
        double speed = GetCurrentDisplaySpeed();
        if (speed <= 0.01) return time; // Avoid division by zero
        return time / speed;
    }

    private string FormatDetailedTime(double seconds)
    {
        int mins = (int)(seconds / 60);
        double secs = seconds % 60;
        int wholeSecs = (int)secs;
        int centisecs = (int)((secs - wholeSecs) * 100);
        return $"{mins:D2}:{wholeSecs:D2}.{centisecs:D2}";
    }
    
    // Slider Value: 0-100
    private double GetLocalSliderValue()
    {
        return SpeedToSlider(GetCurrentDisplaySpeed());
    }
    
    private double SpeedToSlider(double speed)
    {
        // Center (50) = 1.0
        if (speed <= 1.0)
        {
            // 0.1 -> 1.0 maps to 0 -> 50
            double val = (speed - 0.1) / 0.9 * 50;
            return Math.Clamp(val, 0, 50);
        }
        else
        {
            // 1.0 -> 5.0 maps to 50 -> 100
            double val = 50 + (speed - 1.0) / 4.0 * 50;
            return Math.Clamp(val, 50, 100);
        }
    }
    
    private double SliderToSpeed(double val)
    {
        if (val <= 50)
        {
             return 0.1 + (val / 50.0) * 0.9;
        }
        else
        {
             return 1.0 + ((val - 50.0) / 50.0) * 4.0;
        }
    }
    
    private void HandleSpeedSliderInput(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var sliderVal))
        {
            double newSpeed = SliderToSpeed(sliderVal);
            
            // Snap to 1.0 if close (0.9 - 1.1)
            if (newSpeed > 0.9 && newSpeed < 1.1)
            {
                newSpeed = 1.0;
                // We also need to force the slider visual to snap? 
                // Because oninput is continuous, if we don't force render, the thumb might stay at 0.95 position
                // while text shows 1.0.
                // However, updated _localSpeed will correct GetLocalSliderValue.
            }
            
            _localSpeed = newSpeed; // Immediate local update for UI responsiveness
            OnSpeedChanged.InvokeAsync(newSpeed);
        }
    }

    private void HandleProgressChange(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var progress))
        {
            OnProgressChanged.InvokeAsync(progress);
        }
    }
}
