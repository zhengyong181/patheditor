@namespace GCodeWorkbench.UI.Components
@using GCodeWorkbench.UI.Services
@using GCodeWorkbench.UI.Models
@inject SimulationService SimService
@implements IDisposable

<div class="absolute bottom-3 right-3 z-20">
    <div class="bg-[#1b3224]/95 backdrop-blur border border-border-dark shadow-lg rounded-lg px-2.5 py-2 flex flex-col gap-2 w-64">
        <!-- Row 1: Buttons + Speed -->
        <div class="flex items-center gap-2">
            <!-- Play/Pause Button -->
            <button class="size-7 shrink-0 rounded-full flex items-center justify-center bg-primary text-[#122118] hover:brightness-110 transition shadow-sm"
                    @onclick="OnPlayToggle">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    @if (IsPlaying)
                    {
                        <rect x="6" y="4" width="4" height="16" rx="1"/>
                        <rect x="14" y="4" width="4" height="16" rx="1"/>
                    }
                    else
                    {
                        <polygon points="6 3 20 12 6 21 6 3"/>
                    }
                </svg>
            </button>
            <!-- Stop Button -->
            <button class="size-7 shrink-0 rounded-full flex items-center justify-center bg-white/10 text-white/70 hover:bg-white/20 transition shadow-sm"
                    @onclick="OnStop">
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    <rect x="6" y="6" width="12" height="12" rx="1"/>
                </svg>
            </button>
            
            <div class="w-px h-5 bg-border-dark shrink-0"></div>
            
            <!-- Speed Control -->
            <div class="flex-1 flex items-center gap-1.5 min-w-0">
                <div class="flex-1 relative h-1 flex items-center">
                    <!-- Center Marker -->
                    <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-0.5 h-2 bg-white/30 rounded-sm z-0"></div>
                    <input type="range" 
                           min="0" 
                           max="100" 
                           step="1" 
                           value="@GetLocalSliderValue()"
                           @oninput="HandleSpeedSliderInput"
                           class="w-full h-1 bg-black/40 rounded-lg appearance-none cursor-pointer accent-primary relative z-10" />
                </div>
                <span class="text-[9px] font-mono text-white/70 w-6 text-right shrink-0">@GetCurrentDisplaySpeed().ToString("F1")x</span>
            </div>
        </div>
        
        <!-- Row 2: Progress Bar -->
        <div class="flex items-center gap-1.5">
             <div class="flex-1 h-1 flex items-center">
                <input type="range" 
                       min="0" 
                       max="100" 
                       step="0.1" 
                       value="@Progress"
                       @oninput="HandleProgressChange"
                       class="w-full h-1 bg-black/40 rounded-lg appearance-none cursor-pointer accent-primary" />
             </div>
            <span class="text-[9px] font-mono text-white/70 w-6 text-right shrink-0">@Progress.ToString("F0")%</span>
        </div>
        
        <!-- Row 3: Time Display (Scaled by Speed) -->
        <div class="text-center text-[9px] font-mono text-white/60">
            @FormatDetailedTime(GetScaledTime(CurrentTime)) / @FormatDetailedTime(GetScaledTime(TotalTime))
        </div>
    </div>
</div>

@code {
    // Parameters are now mostly read-only properties derived from service state,
    // except for event callbacks which we might keep if parent wants to know.
    // However, to fully decouple, we rely on Service.

    private double CurrentTime => SimService.CurrentTimeSeconds;
    private double TotalTime => SimService.TotalTimeSeconds;
    private double Progress => SimService.Progress * 100;
    private bool IsPlaying => SimService.IsPlaying;

    // We maintain a local copy of PlaybackSpeed because SimService doesn't expose it as a property we can easily bind to
    // (It has SetSpeed method). Actually we can add a getter to Service or track it here.
    // Let's assume we track it here or modify Service. Service has `_speedMultiplier` private.
    // For now, let's just track locally and push to service.
    private double PlaybackSpeed = 1.0;

    private double? _localSpeed; // Stores local speed during drag

    protected override void OnInitialized()
    {
        SimService.OnStateChanged += OnSimStateChanged;
    }

    public void Dispose()
    {
        SimService.OnStateChanged -= OnSimStateChanged;
    }

    private void OnSimStateChanged(SimulationState state)
    {
        // This component DOES need to re-render at 60FPS to show smooth progress bar
        InvokeAsync(StateHasChanged);
    }

    private void OnPlayToggle()
    {
        if (IsPlaying) SimService.Pause();
        else SimService.Play();
    }

    private void OnStop()
    {
        SimService.Stop();
    }

    private double GetCurrentDisplaySpeed()
    {
        return _localSpeed ?? PlaybackSpeed;
    }

    private double GetScaledTime(double time)
    {
        double speed = GetCurrentDisplaySpeed();
        if (speed <= 0.01) return time;
        return time / speed;
    }

    private string FormatDetailedTime(double seconds)
    {
        int mins = (int)(seconds / 60);
        double secs = seconds % 60;
        int wholeSecs = (int)secs;
        int centisecs = (int)((secs - wholeSecs) * 100);
        return $"{mins:D2}:{wholeSecs:D2}.{centisecs:D2}";
    }
    
    private double GetLocalSliderValue()
    {
        return SpeedToSlider(GetCurrentDisplaySpeed());
    }
    
    private double SpeedToSlider(double speed)
    {
        if (speed <= 1.0)
        {
            double val = (speed - 0.1) / 0.9 * 50;
            return Math.Clamp(val, 0, 50);
        }
        else
        {
            double val = 50 + (speed - 1.0) / 4.0 * 50;
            return Math.Clamp(val, 50, 100);
        }
    }
    
    private double SliderToSpeed(double val)
    {
        if (val <= 50)
        {
             return 0.1 + (val / 50.0) * 0.9;
        }
        else
        {
             return 1.0 + ((val - 50.0) / 50.0) * 4.0;
        }
    }
    
    private void HandleSpeedSliderInput(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var sliderVal))
        {
            double newSpeed = SliderToSpeed(sliderVal);
            if (newSpeed > 0.9 && newSpeed < 1.1) newSpeed = 1.0;
            
            _localSpeed = newSpeed;
            PlaybackSpeed = newSpeed;
            SimService.SetSpeed(newSpeed);
        }
    }

    private void HandleProgressChange(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var progress))
        {
            SimService.Seek(progress / 100.0);
        }
    }
}
